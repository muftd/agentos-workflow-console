# Dev Docs 指南-AI编程项目

下面这份就是给 **AI 编程助手（比如 Claude Code）** 用的“Dev Docs 三件套”指南，你之后可以直接丢给它当说明书用。

**先把你标记的 “心尖亮点”放在最前面：**
1. **用文件系统做持久状态容器，对冲聊天上下文的易失性。**
2. **Journal = 时间轴上的流水账；Dev Docs = 针对单个任务的结构化状态快照。**
3. **Dev Docs 的本质是：“让 Claude 在每次重启时，能用最少 token 找回‘当前任务’的方向与路线。”**
4. **统一 schema：**
   * plan.md：这一轮 dev 任务的「目标 & 路线」
   * context.md：这一轮 dev 任务的「环境 & 决策 & 约束 & 经验」
   * tasks.md：这一轮 dev 任务的「行动 & 进度」

---

## 0. 你要解决的痛点（对 AI 说的）

在这个项目里，“Dev Docs”**不是**传统意义上那种庞杂的开发文档，而是：
**用文件系统来承载“当前这一轮 dev 任务的状态快照”，对冲聊天上下文的易失性。**
你（AI）必须把它当成： **“每次重启时，用最少的 token 找回当前任务方向与路线的唯一入口”。**

和其它东西的区别：
* **Journal / 日志流**
  * 角色：按时间往下滚的**流水账**——我今天干了什么、想了什么。
  * 特点：冗长、顺序敏感，适合人类回顾，不适合你每次都扫一遍。
* **Dev Docs 三件套**
  * 角色：**针对单个 dev 任务的结构化状态快照**。
  * 特点：按“任务”而不是“时间”组织；信息已经提炼成你一眼能读懂、可直接执行的形式。

心智模型：
* **Journal = 录像回放**
* **Dev Docs = 当前局面 + 下一步走法的棋谱**

---

## 1. 文件布局与单一任务边界

### 1.1 三个核心文件

在一个 AI 编程项目中，每一轮明确的 dev 任务，都应该有一套 Dev Docs：
* 默认位置：类似“项目根目录/Docs”内
  * plan.md
  * context.md
  * tasks.md
* 如果用户显式指定其他路径（如 devdocs/prompt-optimizer/），以用户描述为准。

### 1.2 “这一轮 dev 任务”的定义（很关键）

一套 Dev Docs 描述的对象是：
* **一个有清晰目标、可在数天内完成的 dev 回合** （例如：为 Prompt 优化器 demo 搭一个 V0.1）
* 不是整个“人生级项目”，也不是“一次 commit”。
* 当用户开启新一轮目标明显不同的开发（比如 V0.1 → V1.0 大版本跃迁），你应当建议新建一套 Dev Docs，而不是在同一套里无限续命。

---

## 2. 设计原则：你必须遵守的几条“铁律”

1. **文件系统 = 持久状态容器**
	* 你不能依赖聊天窗口里的上下文记忆。
	* 一切对“当前任务状态”的认知，以 plan.md / context.md / tasks.md 为准。
2. **少而精 > 面面俱到**
	* 这些文件是给你读的，不是给人类做长篇散文。
	* 信息必须是**压缩过的结论**，而不是原始材料。
3. **一次只服务一个任务**
	* 一套 Dev Docs，只描述一个 dev 任务的目标、环境与进度。
	* 如果一个仓库里有多个独立 demo，应有多套 Dev Docs（路径可区分）。
4. **结构优先于文采**
	* 使用清晰的标题、列表、分节。
	* 你需要“可解析”的结构，而不是漂亮的长段落。

---
⠀
## 3. 三件套各自的职责与内容边界

### 3.1 plan.md：这一轮 dev 任务的「目标 & 路线」

* **你应该如何理解：**
plan.md = **这轮任务要把世界从哪种状态，推到哪种状态？大致按什么阶段推进？**

#### **3.1.1 必须包含的内容**
建议默认结构（供你参考；用户也可以稍做变形）：

```
# Plan: [本轮 dev 任务名称]

## 1. 背景与目标
- 当前版本/现状：
- 本轮想达到的状态（Target State）：
- 验收标准（怎样算“这轮结束”）：

## 2. 阶段划分（Milestones）
- M1: [阶段名] — 预期产出：
- M2: ...
- （可选）M3: ...

## 3. 成功标准（Definition of Done）
- 功能层面：
- 质量层面（稳定性/可维护性）：
- 对外可展示的形态：
**3.1.2 严禁放什么**
* 具体 bug 列表（放到 tasks.md）
* 冗长的技术决策细节（放到 context.md）
* 临时的脑洞/吐槽（放到 Journal 或单独 Notes）
```

---
### 3.2 context.md：这一轮 dev 任务的「环境 & 决策 & 约束 & 经验」

* **你应该如何理解：**
context.md = **为了执行这轮任务，我需要知道的“世界设定与历史决策”。**

* 它回答的问题是：
“如果我现在刚接手这个项目，只读这一个文件，能否**在 1-2 分钟内搞清楚这里有哪些已知的坑、硬约束和曾经踩过的雷**？”

#### **3.2.1 建议结构**

```
# Context: [本轮 dev 任务名称]

## 1. 项目环境 & 基础信息
- 技术栈（前端/后端/部署方式）：
- 外部依赖（API Key、第三方服务、限制）：
- 运行/测试项目的最简指令：

## 2. 已有成果 & 当前状态快照
- 当前已实现的能力（要点式列出）：
- 已经可以稳定运行/展示的部分：

## 3. 关键决策与理由
- 架构/设计选择：
  - 决策：...
  - 理由：...
  - 替代方案 & 放弃原因：...
- 与目标强相关的 trade-off（例如“先牺牲鲁棒性换速度”）

## 4. 约束与风险备忘
- 时间/预算约束：
- 技术约束（模型能力、框架局限）：
- 已知风险 & 临时规避方案：

## 5. 经验 & Best Practices（可选）
- 已踩过的坑：
- 建议重复使用的模式/工具：
```

#### **3.2.2 内容边界判断（结合你和用户刚才练的分类）**

* ✅ 属于 context.md 的典型内容：
  **1** **背景原因**：为什么会有这轮任务，和上游项目的关系。
  **2** **架构决策**：例如“为降低复杂度，本轮不用 LangChain，只用原生 API + 自己写 orchestrator”。
  **3** **风险备忘录**：例如“Replit 免费额度只剩 20 美金，禁止跑大批量测试”。
  **4** **执行过程中沉淀的经验**：例如“Claude Code 在处理 80 份笔记时，一次性 load 全部会超 token，必须分批”。
* ❌ 不应出现在 context.md：
  * 逐条执行日志（“10:32 修了按钮样式，10:48 试了新 prompt…”）
  * 具体「待做事项」或「已完成事项」（放 tasks.md）

---
⠀
### 3.3 tasks.md：这一轮 dev 任务的「行动 & 进度」

* **你应该如何理解：**
tasks.md = **可以直接驱动你执行的 TODO & DONE 列表。**
这是你真正“撸代码 / 改文件”时最常看的那份文件。

#### **3.3.1 建议结构**

```
# Tasks: [本轮 dev 任务名称]

## 0. 任务管理约定
- 粒度：每条任务应该在 0.5~2 小时内可以完成
- 状态标签：
  - [TODO] 尚未开始
  - [DOING] 正在进行
  - [BLOCKED] 卡住，需人类决策
  - [DONE] 已完成，必要时附上简短结果

## 1. 当前任务列表
- [TODO] 为首页搭建基础布局（header / main / footer）
- [TODO] 接入 OpenRouter API，完成最小调用链（不含 UI 配置）
- [TODO] 将“技巧卡片”假数据写死在前端，用于初版展示
- ...

## 2. 已完成任务（精简归档）
- [DONE] 初始化 Replit 项目 & 推送到 GitHub
  - 结果：已在 `main` 分支，URL: ...
- [DONE] 完成 AI-侧 Prompt 草案 V0.1（存放在 `prompts/skill-studio.md`）

## 3. 阻塞点
- [BLOCKED] 需要用户提供 OpenRouter API Key
- [BLOCKED] 需要用户确认 demo 命名 & 最终展示场景
```

#### **3.3.2 使用原则**

* **你在执行时，应优先以** **tasks.md** **为入口**：
  	1. 取当前 [TODO] 列表
  	2. 结合 plan.md 的阶段目标，挑选下一条任务或建议重排
* 执行完成后，**你有责任**更新对应任务的状态，并将关键结果一句话写入（如果用户没禁止你改文件）。

---

## 4. 你（AI）应该如何在工作流中使用 Dev Docs

### 4.1 会话开始 / 重连时
每次用户在这个项目里叫醒你，你都应该默认做三件事（除非用户明确说“跳过 dev docs”）：
1. 尝试读取（或让自己“想象已读取”）：
	* plan.md
	* context.md
	* tasks.md
2. 用一句话在心里回答三个问题：
	* **现在这轮任务要把世界从哪儿推到哪儿？**（看 plan.md）
	* **当前世界长什么样？有哪些坑要避？**（看 context.md）
	* **我们下一步具体要做哪几件事？**（看 tasks.md）
3. 在回复用户之前，把这三点浓缩成简短的 “当前理解”，以便人类校准（可选，但推荐）。

---

### 4.2 处理中途

在开发过程中，你应当：
* 当用户说“**帮我更新 plan**”：
  * 和用户对齐新目标 / 新阶段，编辑 plan.md 中相应部分。
* 当用户说“**记录一下这个决策/坑**”：
  * 将信息写入 context.md 的“关键决策”或“经验 & Best Practices”。
* 当用户说“**把这轮要做的事情整理成任务**”：
  * 帮他把自然语言目标拆成 0.5~2 小时粒度的任务，写入 tasks.md，[TODO] 状态。

### 4.3 小心不要做的事

* 不要在没有用户暗示的情况下，擅自重构 Dev Docs 结构。
* 不要把大段日志直接塞进 context.md / tasks.md，那是 Journal 的角色。
* 不要在多个任务之间混用同一套 Dev Docs，导致“一个文件写了两个项目的东西”。

---
⠀
## 5. Few-shot 示例：Prompt 优化器 Demo 的 Dev Docs（简版）

下面是一个 **“Prompt 想象力工作室 / Prompt 优化器 Demo”** 的极简示例，你可以把它当 few-shot 参考。

### 5.1 plan.md 示例

```
# Plan: Prompt 想象力工作室 Demo（V0.1）

## 1. 背景与目标
- 当前版本：
  - 还没有可访问的 Web demo，但有一篇长文《Prompt 即人机交互协议》作为知识母本。
- 本轮目标：
  - 在 Replit 上搭建一个可在线访问的 Web demo，
  - 能够展示若干「Prompt 技巧」的魔法时刻，用假数据/弱接入也没关系。
- 验收标准：
  - 有可访问的 URL；
  - 新用户 30 秒内能理解这是一个“Prompt 想象力工作室”，而不是通用聊天框；
  - 至少 3 个可交互的技巧卡片，可以跑出看得见的效果。

## 2. 阶段划分（Milestones）
- M1: 前端壳子搭建完毕（静态页面 + 假数据技巧卡片）
- M2: 接入一个最小的 AI 调用链（可用单一模型 + 固定 prompt）
- M3: 补充 3 个代表性的技巧 + 对外展示版本自测通过

## 3. 成功标准（Definition of Done）
- 功能：页面可加载、按钮可点击、AI 返回结果不报错。
- 体验：非技术用户能在 1 分钟内完成一次“输入 → 看到结果”的闭环。
- 展示：作者可以把链接发给别人，作为个人 AI 能力的信任中间物。
```

---
### 5.2 context.md 示例

```
# Context: Prompt 想象力工作室 Demo（V0.1）

## 1. 项目环境 & 基础信息
- 技术栈：
  - 前端：纯 HTML/CSS/少量 JS（Replit 模板）
  - 后端：Replit 提供的 Python/Node 环境（二选一，根据仓库实际情况）
- 外部依赖：
  - 暂定接入 OpenRouter（未来可换成官方 API）
  - 免费额度有限，本轮优先做 demo，不做大规模调用
- 运行方式：
  - 在 Replit 直接运行/预览；
  - 代码同步到 GitHub 仓库 `prompt-imagine`。

## 2. 已有成果 & 当前状态快照
- 已有：
  - 一个最小的静态页面骨架，含标题/说明/占位按钮。
  - GitHub 仓库已创建并与 Replit 关联。
- 本轮前置决策：
  - 只做单页应用（SPA 级别复杂度太高，暂不考虑）。

## 3. 关键决策与理由
- 决策：前期不做复杂权限/多用户系统。
  - 理由：本轮目标是“展示作者的 Prompt 能力”，不是做 SaaS。
- 决策：技巧内容使用“长文中已提炼的技巧清单”作为数据源。
  - 理由：减少在 demo 中重新发明术语的开销，保持与知识母本一致。

## 4. 约束与风险备忘
- 时间约束：Replit 额度只剩约 6 小时使用窗，必须优先完成 M1 & M2。
- 风险：如果 API 接入在本轮搞不定，可以退而求其次，用“假响应”模拟效果。

## 5. 经验 & Best Practices
- 不要在一次对话中让 AI 同时“重写前端 + 规划后端 + 更新 Dev Docs”，容易超上下文并乱套。
- 推荐节奏：每次对话只推进 1~2 个 `tasks`，完成后立即更新 `tasks.md` 与必要的 `context` 条目。
```

---
### 5.3 tasks.md 示例

```
# Tasks: Prompt 想象力工作室 Demo（V0.1）

## 0. 任务管理约定
- 单任务粒度控制在 0.5~2 小时。
- 状态标签：[TODO] / [DOING] / [BLOCKED] / [DONE]。

## 1. 当前任务列表
- [TODO] 梳理 3 个代表性的 Prompt 技巧，写成“技巧卡片”数据结构（先写死在前端）。
- [TODO] 为首页搭建基础布局（标题区 + 技巧列表区 + 结果展示区）。
- [TODO] 在 Replit 后端创建一个最小 API endpoint，返回固定的示例响应。
- [TODO] 将前端按钮点击 → 调用后端 endpoint → 把响应渲染到结果区。

## 2. 已完成任务（精简归档）
- [DONE] 在 Replit 创建项目并绑定 GitHub 仓库 `prompt-imagine`。
  - 结果：项目可通过 Replit 访问，基本 Hello World 页面可显示。
- [DONE] 确认本轮 Demo 的定位与验收标准（写入 `plan.md`）。

## 3. 阻塞点
- [BLOCKED] 需要用户确认：本轮是否一定要接入真实 OpenRouter，还是可以先用假数据演示？
```

---

如果你之后在别的项目里要用这套模式（比如某个新 Skill 的实现、AgentOS 某个 Coach 的迭代），只需要：
1. 为那一轮 dev 任务新建一套 plan.md / context.md / tasks.md。
2. 把这份“Dev Docs 说明书”一并喂给负责的 AI（claude code / Coach E 等）。
⠀它就能在每次重启时，用很少的 token，重新站回同一块战场继续往前打。